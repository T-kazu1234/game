// Generated by CoffeeScript 1.6.2
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  $(function() {
    var BGM_URL, Board, IMG_URL, PRELOAD_MATERIAL, Panel, conf, createEndScene, createStartScene, game, getConf, getParameterByName, rand, randInAry;

    enchant();
    BGM_URL = './sounds/bgm01.wav';
    IMG_URL = 'images/enchant.png';
    PRELOAD_MATERIAL = ['images/start.png', IMG_URL, BGM_URL];
    game = null;
    getParameterByName = function(name, def_val) {
      var regex, regexS, results;

      if (def_val == null) {
        def_val = "";
      }
      name = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
      regexS = "[\\?&]" + name + "=([^&#]*)";
      regex = new RegExp(regexS);
      results = regex.exec(window.location.search);
      if (results === null) {
        return def_val;
      } else {
        return decodeURIComponent(results[1].replace(/\+/g, " "));
      }
    };
    rand = function(num) {
      return Math.floor(Math.random() * num);
    };
    randInAry = function(ary) {
      return ary[rand(ary.length)];
    };
    Panel = (function(_super) {
      __extends(Panel, _super);

      function Panel(conf, position) {
        var surface, sx0, sy0, _ref;

        this.conf = conf;
        this.position = position != null ? position : 0;
        Panel.__super__.constructor.call(this, conf.cell_w, conf.cell_h);
        this.moved = false;
        surface = new Surface(conf.cell_w, conf.cell_h);
        _ref = [(position % 4) * conf.cell_w, (Math.floor(position / 4)) * conf.cell_h], sx0 = _ref[0], sy0 = _ref[1];
        surface.draw(game.assets[IMG_URL], sx0, sy0, conf.cell_w, conf.cell_h, 0, 0, conf.cell_w, conf.cell_h);
        surface.context.rect(0, 0, conf.cell_w, conf.cell_h);
        surface.context.strokeStyle = '#666666';
        surface.context.stroke();
        this.image = surface;
        this.on("touchstart", function() {
          if (!this.moved) {
            return this.tl.fadeTo(0.5, 1);
          }
        });
        this.on("touchend", function() {
          var j, node, nodes, pos, x, y, _i, _len, _ref1, _results;

          if (!this.moved) {
            this.tl.fadeTo(1, 1);
            nodes = this.parentNode.childNodes;
            _ref1 = [[1, 0], [0, 1], [-1, 0], [0, -1]];
            _results = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              j = _ref1[_i];
              if (this.moved) {
                break;
              }
              x = j[0], y = j[1];
              _results.push((function() {
                var _j, _len1, _results1;

                _results1 = [];
                for (_j = 0, _len1 = nodes.length; _j < _len1; _j++) {
                  node = nodes[_j];
                  pos = node.position;
                  if (pos === this.position + x + y * this.conf.cell_x) {
                    if (node.x === 320) {
                      node.position = this.position;
                      this.position = pos;
                      this.moved = true;
                      this.tl.moveTo((this.position % this.conf.cell_x) * this.conf.cell_w, Math.floor(this.position / this.conf.cell_x) * this.conf.cell_h, 3, QUAD_EASEOUT);
                      this.tl.then(function() {
                        this.moved = false;
                        return game.checkFinish();
                      });
                      break;
                    } else {
                      _results1.push(void 0);
                    }
                  } else {
                    _results1.push(void 0);
                  }
                }
                return _results1;
              }).call(this));
            }
            return _results;
          }
        });
      }

      return Panel;

    })(Sprite);
    Board = (function() {
      function Board(conf) {
        var i, panel, _i, _ref;

        this.conf = conf;
        this.panels = [];
        for (i = _i = 0, _ref = conf.celles; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          panel = new Panel(conf, i);
          game.rootScene.addChild(panel);
          this.panels.push(panel);
        }
        this.shuffle();
      }

      Board.prototype.shuffle = function() {
        var i, _i, _results;

        _results = [];
        for (i = _i = 1; _i < 10; i = ++_i) {
          this.do_shuffle();
          if (this.checkFinish() === false) {
            break;
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };

      Board.prototype.do_shuffle = function() {
        var count, d, i, p, positions, tmp, x, y, _i, _j, _k, _ref, _ref1, _ref2, _ref3, _results;

        positions = (function() {
          _results = [];
          for (var _i = 0, _ref = this.conf.celles; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
          return _results;
        }).apply(this);
        this.hideCell_idx = null;
        for (i = _j = 0, _ref1 = this.conf.celles; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          this.panels[i].position = i;
          this.panels[i].frame = i;
          this.panels[i].x = (this.panels[i].position % this.conf.cell_x) * this.conf.cell_w;
          this.panels[i].y = Math.floor(this.panels[i].position / this.conf.cell_x) * this.conf.cell_h;
          this.panels[i].moved = false;
        }
        p = rand(this.conf.celles);
        count = this.conf.shuffle;
        while (count > 0) {
          _ref2 = randInAry([[1, 0], [0, 1], [-1, 0], [0, -1]]), x = _ref2[0], y = _ref2[1];
          if (!((p % this.conf.cell_x === 0 && x < 0) || (p % this.conf.cell_x === (this.conf.cell_x - 1) && x > 0) || (p < this.conf.cell_y && y < 0) || (p > (this.conf.celles - this.conf.cell_x - 1) && y > 0))) {
            d = p + x + y * this.conf.cell_x;
            tmp = positions[p];
            positions[p] = positions[d];
            positions[d] = tmp;
            p = d;
            count--;
          }
        }
        this.hideCell_idx = p;
        for (i = _k = 0, _ref3 = this.conf.celles; 0 <= _ref3 ? _k < _ref3 : _k > _ref3; i = 0 <= _ref3 ? ++_k : --_k) {
          this.panels[i].position = positions[i];
          this.panels[i].x = (this.panels[i].position % this.conf.cell_x) * this.conf.cell_w;
          this.panels[i].y = Math.floor(this.panels[i].position / this.conf.cell_x) * this.conf.cell_h;
        }
        if (this.hideCell_idx !== null) {
          return this.panels[this.hideCell_idx].x = this.panels[this.hideCell_idx].y = 320;
        }
      };

      Board.prototype.checkFinish = function() {
        var i, isFinish, _i, _ref;

        isFinish = true;
        for (i = _i = 0, _ref = this.conf.celles; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          if (this.panels[i].position !== parseInt(i, 10)) {
            isFinish = false;
          }
        }
        return isFinish;
      };

      Board.prototype.gameover = function() {
        var _this = this;

        this.panels[this.hideCell_idx].tl.moveTo((this.panels[this.hideCell_idx].position % this.conf.cell_x) * this.conf.cell_w, Math.floor(this.panels[this.hideCell_idx].position / this.conf.cell_x) * this.conf.cell_h, game.fps / 2, QUAD_EASEOUT);
        return this.panels[this.hideCell_idx].tl.then(function() {
          var endScene, endTime;

          endTime = new Date().getTime() - game.startTime;
          alert("" + ((endTime / 1000).toFixed(2)) + " 秒でクリア！");
          endScene = createEndScene();
          game.pushScene(endScene);
          return _this.shuffle();
        });
      };

      return Board;

    })();
    createStartScene = function() {
      var image, scene, _ref;

      scene = new Scene();
      image = new Sprite(236, 48);
      image.image = game.assets['images/start.png'];
      _ref = [42, 136], image.x = _ref[0], image.y = _ref[1];
      scene.addChild(image);
      scene.addEventListener(Event.TOUCH_START, function(e) {
        game.popScene();
        return game.startTime = new Date().getTime();
      });
      return scene;
    };
    createEndScene = function() {
      var image, scene, _ref;

      scene = new Scene();
      image = new Sprite(320, 320);
      image.image = game.assets['images/enchant.png'];
      _ref = [0, 0], image.x = _ref[0], image.y = _ref[1];
      scene.addChild(image);
      scene.addEventListener(Event.TOUCH_START, function(e) {
        return game.popScene();
      });
      return scene;
    };
    getConf = function() {
      var bgm, cell_x, cell_y, conf, shuffle_count;

      cell_x = parseInt(getParameterByName("x", 4), 10);
      cell_y = parseInt(getParameterByName("y", 4), 10);
      shuffle_count = parseInt(getParameterByName("s", 100), 10);
      bgm = parseInt(getParameterByName("b", 1), 10);
      return conf = {
        cell_x: cell_x,
        cell_y: cell_y,
        celles: cell_x * cell_y,
        cell_w: 320 / cell_x,
        cell_h: 320 / cell_y,
        shuffle: shuffle_count,
        bgm: bgm
      };
    };
    game = new Game(320, 320);
    game.fps = 24;
    game.preload(PRELOAD_MATERIAL);
    conf = getConf();
    game.onload = function() {
      var bgm, board, setBGM;

      game.rootScene.backgroundColor = "#000000";
      board = new Board(conf);
      game.pushScene(createStartScene());
      bgm = game.assets[BGM_URL];
      game.checkFinish = function() {
        if (board.checkFinish()) {
          return board.gameover();
        }
      };
      $("#bgm-on").click(function() {
        return setBGM(false);
      });
      $("#bgm-off").click(function() {
        return setBGM(true);
      });
      $("#shuffle").click(function() {
        var b, s, x, y;

        x = $("#cell-x").val();
        y = $("#cell-y").val();
        s = conf.shuffle;
        b = $("#bgm-on").css("display") === "none" ? 0 : 1;
        return window.location = "./index.html?x=" + x + "&y=" + y + "&s=" + s + "&b=" + b;
      });
      setBGM = function(v) {
        if (v) {
          $("#bgm-on").show();
          $("#bgm-off").hide();
          bgm.play();
          if (bgm._element) {
            bgm._element.loop = true;
          }
          if (bgm.src) {
            return bgm.src.loop = true;
          }
        } else {
          $("#bgm-on").hide();
          $("#bgm-off").show();
          return bgm.pause();
        }
      };
      $("#cell-x").val(conf.cell_x);
      $("#cell-y").val(conf.cell_y);
      return setBGM(conf.bgm === 1);
    };
    return game.start();
  });

}).call(this);
